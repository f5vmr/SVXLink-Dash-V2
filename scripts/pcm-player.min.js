function PCMPlayer(t) {
    this.init(t);
}

function iOS() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) ||
           (navigator.userAgent.includes("Mac") && "ontouchend" in document);
}

function SVXPlayer(t, i) {
    this.ws = null;
    this.socketURL = "ws://" + document.location.hostname + ":" + t;
    this.sampleRate = iOS() ? 32000 : 48000;
    this.player = new PCMPlayer({
        encoding: "16bitInt",
        channels: 1,
        sampleRate: this.sampleRate,
        flushingTime: 2000
    });
    this.btn = i;
    this.btnDefault = i.style.backgroundColor;
    this.stop();

    window.addEventListener("unload", function() {
        this.destroy();
    });
}

function playAudioToggle(t, i) {
    if (window.svxp === undefined) window.svxp = new SVXPlayer(t, i);
    svxp.isPlaying() ? window.svxp.stop() : window.svxp.play();
}
SVXPlayer.prototype.play = function() {
    this.stop();
    this.ws = new WebSocket(this.socketURL);
    const self = this;

    this.ws.onopen = function() {
        // Connected to WebSocket server
        self.btn.style.backgroundColor = 'blue';
        self.btn.innerHTML = '<b><img src="images/speaker.png" alt="" style="vertical-align:middle">&nbsp;Connected</b>';
    };

    this.ws.onmessage = function(event) {
        // Receiving audio data
        const arrayBuffer = event.data;
        const reader = new FileReader();
        reader.onload = function() {
            const buffer = new Uint8Array(this.result);
            self.player.feed(buffer);
        };
        reader.readAsArrayBuffer(arrayBuffer);

        // Indicate audio is playing (listening)
        self.btn.style.backgroundColor = 'green';
        self.btn.innerHTML = '<b><img src="images/speaker.png" alt="" style="vertical-align:middle">&nbsp;Listening</b>';
    };

    this.ws.onclose = function() {
        // Connection closed
        self.btn.style.backgroundColor = self.btnDefault;
        self.btn.innerHTML = '<b><img src="images/speaker.png" alt="" style="vertical-align:middle">&nbsp;RX Monitor</b>';
    };
};
SVXPlayer.prototype.stop = function() {
    if (this.ws) {
        this.ws.close();
        this.ws = null;
    }
    this.player.stop();
    this.btn.style.backgroundColor = this.btnDefault;
    this.btn.innerHTML = '<b><img src="images/speaker.png" alt="" style="vertical-align:middle">&nbsp;RX Monitor</b>';
};

PCMPlayer.prototype.init = function(t) {
    this.option = Object.assign({}, {
        encoding: "16bitInt",
        channels: 1,
        sampleRate: 48000,
        flushingTime: 1000
    }, t);

    this.samples = new Float32Array();
    this.flush = this.flush.bind(this);
    this.interval = setInterval(this.flush, this.option.flushingTime);
    this.maxValue = this.getMaxValue();
    this.typedArray = this.getTypedArray();
    this.createContext();
};

PCMPlayer.prototype.getMaxValue = function() {
    const maxValues = {
        "8bitInt": 128,
        "16bitInt": 32768,
        "32bitInt": 2147483648,
        "32bitFloat": 1
    };
    return maxValues[this.option.encoding] ? maxValues[this.option.encoding] : maxValues["16bitInt"];
};

PCMPlayer.prototype.getTypedArray = function() {
    const types = {
        "8bitInt": Int8Array,
        "16bitInt": Int16Array,
        "32bitInt": Int32Array,
        "32bitFloat": Float32Array
    };
    return types[this.option.encoding] ? types[this.option.encoding] : types["16bitInt"];
};

PCMPlayer.prototype.createContext = function() {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.gainNode = this.audioCtx.createGain();
    this.gainNode.gain.value = 1;
    this.gainNode.connect(this.audioCtx.destination);
    this.startTime = this.audioCtx.currentTime;
};

PCMPlayer.prototype.isTypedArray = function(t) {
    return t.byteLength && t.buffer && t.buffer.constructor == ArrayBuffer;
};

PCMPlayer.prototype.feed = function(t) {
    if (this.isTypedArray(t)) {
        t = this.getFormatedValue(t);
        const i = new Float32Array(this.samples.length + t.length);
        i.set(this.samples, 0);
        i.set(t, this.samples.length);
        this.samples = i;
    }
};

PCMPlayer.prototype.getFormatedValue = function(t) {
    const arr = new this.typedArray(t.buffer);
    const f32 = new Float32Array(arr.length);
    for (let e = 0; e < arr.length; e++) f32[e] = arr[e] / this.maxValue;
    return f32;
};

PCMPlayer.prototype.volume = function(t) {
    this.gainNode.gain.value = t;
};

PCMPlayer.prototype.stop = function() {
    if (this.interval) clearInterval(this.interval);
    this.samples = null;
};

PCMPlayer.prototype.play = function() {
    this.samples = new Float32Array();
    this.interval = setInterval(this.flush, this.option.flushingTime);
};

PCMPlayer.prototype.destroy = function() {
    this.stop();
    this.audioCtx.close();
    this.audioCtx = null;
};

PCMPlayer.prototype.flush = function() {
    if (!this.samples.length) return;

    const s = this.audioCtx.createBufferSource();
}

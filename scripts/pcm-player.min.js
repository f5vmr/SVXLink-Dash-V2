function PCMPlayer(options) {
    this.init(options);
}

function iOS() {
    return ["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform) 
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
}
function SVXPlayer(port, btn) {
    this.ws = window.svxpSocket || null; // use the page-level WS if it exists
    this.socketURL = "ws://" + document.location.hostname + ":" + port;
    this.sampleRate = iOS() ? 32000 : 48000;
    this.player = new PCMPlayer({ encoding: "16bitInt", channels: 1, sampleRate: this.sampleRate, flushingTime: 2000 });
    this.btn = btn;
    this.btnDefault = btn.style.backgroundColor;

    // Make sure page-level WS exists
    if (!window.svxpSocket) {
        window.svxpSocket = new WebSocket(this.socketURL);
        window.svxpSocket.binaryType = "arraybuffer";

        window.svxpSocket.addEventListener("message", (event) => {
            const data = new Uint8Array(event.data);
            this.player.feed(data);
        });

        window.svxpSocket.addEventListener("close", () => {
            console.log("WebSocket closed for this page.");
        });
    }

    this.ws = window.svxpSocket; // store WS reference
    this.stop();
    window.addEventListener("unload", () => this.destroy());
}

//function SVXPlayer(port, btn) {
//    this.ws = null;
//    this.socketURL = "ws://" + document.location.hostname + ":" + port;
//    this.sampleRate = iOS() ? 32000 : 48000;
//    this.player = new PCMPlayer({
//        encoding: "16bitInt",
//        channels: 1,
//        sampleRate: this.sampleRate,
//        flushingTime: 2000
//    });
//    this.btn = btn;
//    this.btnDefault = btn.style.backgroundColor;
//    this.stop();
//    window.addEventListener("unload", () => { this.destroy(); });
//}

function playAudioToggle(port, btn) {
    if (window.svxp === undefined) window.svxp = new SVXPlayer(port, btn);
    svxp.isPlaying() ? svxp.stop() : svxp.play();
}

PCMPlayer.prototype.init = function(options) {
    this.option = Object.assign({ encoding:"16bitInt", channels:1, sampleRate:48000, flushingTime:1000 }, options);
    this.samples = new Float32Array();
    this.flush = this.flush.bind(this);
    this.interval = setInterval(this.flush, this.option.flushingTime);
    this.maxValue = this.getMaxValue();
    this.typedArray = this.getTypedArray();
    this.createContext();
};

PCMPlayer.prototype.getMaxValue = function() {
    const map = { "8bitInt": 128, "16bitInt": 32768, "32bitInt": 2147483648, "32bitFloat": 1 };
    return map[this.option.encoding] || map["16bitInt"];
};

PCMPlayer.prototype.getTypedArray = function() {
    const map = { "8bitInt": Int8Array, "16bitInt": Int16Array, "32bitInt": Int32Array, "32bitFloat": Float32Array };
    return map[this.option.encoding] || map["16bitInt"];
};

PCMPlayer.prototype.createContext = function() {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.gainNode = this.audioCtx.createGain();
    this.gainNode.gain.value = 1;
    this.gainNode.connect(this.audioCtx.destination);
    this.startTime = this.audioCtx.currentTime;
};

PCMPlayer.prototype.isTypedArray = function(t) {
    return t.byteLength && t.buffer && t.buffer.constructor === ArrayBuffer;
};

PCMPlayer.prototype.feed = function(t) {
    if (this.isTypedArray(t)) t = this.getFormatedValue(t);
    const combined = new Float32Array(this.samples.length + t.length);
    combined.set(this.samples, 0);
    combined.set(t, this.samples.length);
    this.samples = combined;
};

PCMPlayer.prototype.getFormatedValue = function(t) {
    t = new this.typedArray(t.buffer);
    const out = new Float32Array(t.length);
    for (let i = 0; i < t.length; i++) out[i] = t[i] / this.maxValue;
    return out;
};

PCMPlayer.prototype.volume = function(val) {
    this.gainNode.gain.value = val;
};

PCMPlayer.prototype.stop = function() {
    if (this.interval) clearInterval(this.interval);
    this.samples = null;
};

PCMPlayer.prototype.play = function() {
    this.samples = new Float32Array();
    this.interval = setInterval(this.flush, this.option.flushingTime);
};

PCMPlayer.prototype.destroy = function() {
    this.stop();
    this.audioCtx.close();
    this.audioCtx = null;
};

PCMPlayer.prototype.flush = function() {
    if (!this.samples.length) return;

    const channels = this.option.channels;
    const length = this.samples.length / channels;
    const buffer = this.audioCtx.createBuffer(channels, length, this.option.sampleRate);

    for (let r = 0; r < channels; r++) {
        const channelData = buffer.getChannelData(r);
        for (let i = r, n = 50, j = 0; j < length; j++) {
            channelData[j] = this.samples[i];
            if (j < 50) channelData[j] *= j / 50;
            if (j >= length - 51) channelData[j] *= n-- / 50;
            i += channels;
        }
    }

    const source = this.audioCtx.createBufferSource();
    if (this.startTime < this.audioCtx.currentTime) this.startTime = this.audioCtx.currentTime;
    source.buffer = buffer;
    source.connect(this.gainNode);
    source.start(this.startTime);
    this.startTime += buffer.duration;
    this.samples = new Float32Array();
};

// ------------------- Updated play method -------------------
SVXPlayer.prototype.play = function () {
    this.btn.style.backgroundColor = "#008000";
    this.player.play();
    // Don't create a new WebSocket here!
};

//SVXPlayer.prototype.play = function() {
//    if (this.ws) return; // Prevent multiple connections
//
//    this.btn.style.backgroundColor = "#008000";
//    this.ws = new WebSocket(this.socketURL);
//    this.ws.binaryType = "arraybuffer";
//    this.ws.closing = false;
//
//    this.ws.addEventListener("message", (event) => {
//        const data = new Uint8Array(event.data);
//        if (this.player.option.sampleRate === 48000) {
//            this.player.feed(data);
//        } else {
//            // resampling logic for other sample rates
//            const ratio = this.player.option.sampleRate / 48000;
//            const resampled = new Uint8Array(data.length * ratio);
//            let a = 0;
//            for (let i = 0; i < data.length; i += 2) {
//                for (let s = 0; s < ratio; s++) {
//                    resampled[a++] = data[i];
//                    resampled[a++] = data[i+1];
//                }
//            }
//            this.player.feed(resampled);
//        }
//    });
//
//    this.player.play();
//
//    this.ws.onclose = () => {
//        if (!this.ws.closing) {
//            this.ws = null;
//            this.btn.style.backgroundColor = "#ff0000";
//            setTimeout(() => { this.play(); }, 5000);
//        }
//    };
//};

// -----------------------------------------------------------

SVXPlayer.prototype.stop = function() {
    this.player.stop();
    if (this.isPlaying()) {
        this.ws.closing = true;
        this.ws.close();
        this.ws = null;
    }
    this.btn.style.backgroundColor = this.btnDefault;
};

SVXPlayer.prototype.isPlaying = function() {
    return this.ws !== null;
};

SVXPlayer.prototype.destroy = function() {
    this.stop();
    this.player.destroy();
};

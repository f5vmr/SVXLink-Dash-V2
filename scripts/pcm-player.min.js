// Shared WebSocket connection created on page load
const wsPort = 8001;
const sharedWS = new WebSocket("ws://" + document.location.hostname + ":" + wsPort);
sharedWS.binaryType = 'arraybuffer';

// Listen for messages (listener count + audio)
sharedWS.onmessage = (event) => {
    if (typeof event.data === 'string') {
        try {
            const msg = JSON.parse(event.data);
            if (msg.type === 'listenerCount') {
                updateListenerCountDisplay(msg.count);
            }
        } catch (e) {
            // Ignore invalid JSON
        }
    } else if (window.svxp && window.svxp.isPlaying && window.svxp.player) {
        window.svxp.player.feed(event.data);
    }
};

function PCMPlayer(t) {
    this.init(t);
}

function iOS() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) ||
           (navigator.userAgent.includes("Mac") && "ontouchend" in document);
}

// ðŸ”¹ Shared WebSocket â€“ one per tab
let sharedWS = null;
function getSharedWebSocket(port) {
    if (!sharedWS) {
        sharedWS = new WebSocket("ws://" + document.location.hostname + ":" + port);
        sharedWS.binaryType = 'arraybuffer';
        sharedWS.onmessage = (event) => {
            if (typeof event.data === 'string') {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'listenerCount') {
                        updateListenerCountDisplay(msg.count);
                    }
                } catch (e) {
                    // Ignore invalid JSON
                }
            } else if (window.svxp && window.svxp.player) {
                // Feed audio only if playback is active
                window.svxp.player.feed(event.data);
            }
        };
    }
    return sharedWS;
}

function SVXPlayer(t, i) {
    //this.ws = getSharedWebSocket(t); // reuse shared connection
    this.ws = sharedWS;
    this.sampleRate = iOS() ? 32000 : 48000;
    this.player = new PCMPlayer({
        encoding: "16bitInt",
        channels: 1,
        sampleRate: this.sampleRate
    });

    this.btn = i;
    this.btnDefault = i.style.backgroundColor;

    window.addEventListener("unload", () => this.destroy());
}

// Update a DOM element with the listener count
function updateListenerCountDisplay(count) {
    const el = document.getElementById('listenerCount');
    if (el) el.textContent = count > 0 ? `Listeners: ${count}` : '';
}

function playAudioToggle(t, i) {
    if (!window.svxp) window.svxp = new SVXPlayer(t, i);
    if (window.svxp.isPlaying) {
        window.svxp.stop();
        i.style.backgroundColor = window.svxp.btnDefault;
    } else {
        window.svxp.play();
        i.style.backgroundColor = 'green';
    }
    window.svxp.isPlaying = !window.svxp.isPlaying;
}

PCMPlayer.prototype.init = function(t) {
    this.option = Object.assign({}, {
        encoding: "16bitInt",
        channels: 1,
        sampleRate: 48000,
        flushingTime: 1000
    }, t);

    this.samples = new Float32Array();
    this.flush = this.flush.bind(this);
    this.interval = setInterval(this.flush, this.option.flushingTime);
    this.maxValue = this.getMaxValue();
    this.typedArray = this.getTypedArray();
    this.createContext();
};

PCMPlayer.prototype.getMaxValue = function() {
    const maxValues = {
        "8bitInt": 128,
        "16bitInt": 32768,
        "32bitInt": 2147483648,
        "32bitFloat": 1
    };
    return maxValues[this.option.encoding] || maxValues["16bitInt"];
};

PCMPlayer.prototype.getTypedArray = function() {
    const types = {
        "8bitInt": Int8Array,
        "16bitInt": Int16Array,
        "32bitInt": Int32Array,
        "32bitFloat": Float32Array
    };
    return types[this.option.encoding] || types["16bitInt"];
};

PCMPlayer.prototype.createContext = function() {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.gainNode = this.audioCtx.createGain();
    this.gainNode.gain.value = 1;
    this.gainNode.connect(this.audioCtx.destination);
    this.startTime = this.audioCtx.currentTime;
};

PCMPlayer.prototype.isTypedArray = function(t) {
    return t.byteLength && t.buffer && t.buffer.constructor == ArrayBuffer;
};

PCMPlayer.prototype.feed = function(t) {
    if (this.isTypedArray(t)) {
        t = this.getFormatedValue(t);
        const i = new Float32Array(this.samples.length + t.length);
        i.set(this.samples, 0);
        i.set(t, this.samples.length);
        this.samples = i;
    }
};

PCMPlayer.prototype.getFormatedValue = function(t) {
    const arr = new this.typedArray(t.buffer);
    const f32 = new Float32Array(arr.length);
    for (let e = 0; e < arr.length; e++) f32[e] = arr[e] / this.maxValue;
    return f32;
};

PCMPlayer.prototype.volume = function(t) {
    this.gainNode.gain.value = t;
};

PCMPlayer.prototype.stop = function() {
    if (this.interval) clearInterval(this.interval);
    this.samples = null;
};

PCMPlayer.prototype.play = function() {
    this.samples = new Float32Array();
    this.interval = setInterval(this.flush, this.option.flushingTime);
};

PCMPlayer.prototype.destroy = function() {
    this.stop();
    if (this.audioCtx) this.audioCtx.close();
    this.audioCtx = null;
};

PCMPlayer.prototype.flush = function() {
    if (!this.samples.length) return;
    const s = this.audioCtx.createBufferSource();
};
